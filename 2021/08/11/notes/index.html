<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eccent.icu","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="至2021-08-11 object是引用数据类型，且只存储于堆(heap)中        ( X )  ​    解析：基本类型都存储在栈中，引用数据类型的引用存储在栈中，引用对象的内容存储在堆中  函数式声明有提升现象，函数表达式不会提升  ​    解析： 12345678910&#x2F;&#x2F; 代码片段1，实际执行顺序：先声明函数，再调用check(&amp;#x27;first&amp;#x27;);functi">
<meta property="og:type" content="article">
<meta property="og:title" content="随手一记">
<meta property="og:url" content="http://eccent.icu/2021/08/11/notes/index.html">
<meta property="og:site_name" content="ECcCCcC">
<meta property="og:description" content="至2021-08-11 object是引用数据类型，且只存储于堆(heap)中        ( X )  ​    解析：基本类型都存储在栈中，引用数据类型的引用存储在栈中，引用对象的内容存储在堆中  函数式声明有提升现象，函数表达式不会提升  ​    解析： 12345678910&#x2F;&#x2F; 代码片段1，实际执行顺序：先声明函数，再调用check(&amp;#x27;first&amp;#x27;);functi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://eccent.icu/2021/08/11/notes/2.jpg">
<meta property="og:image" content="http://eccent.icu/2021/08/11/notes/1.jpg">
<meta property="og:image" content="http://eccent.icu/2021/08/11/notes/3.jpg">
<meta property="article:published_time" content="2021-08-11T13:57:54.000Z">
<meta property="article:modified_time" content="2021-08-18T15:07:37.940Z">
<meta property="article:author" content="eccent">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://eccent.icu/2021/08/11/notes/2.jpg">

<link rel="canonical" href="http://eccent.icu/2021/08/11/notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>随手一记 | ECcCCcC</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ECcCCcC</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-link">

    <a href="/link/" rel="section"><i class="fa fa-heart fa-fw"></i>链接</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://eccent.icu/2021/08/11/notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="eccent">
      <meta itemprop="description" content="Stay Alive">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ECcCCcC">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          随手一记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-11 21:57:54" itemprop="dateCreated datePublished" datetime="2021-08-11T21:57:54+08:00">2021-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-18 23:07:37" itemprop="dateModified" datetime="2021-08-18T23:07:37+08:00">2021-08-18</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="至2021-08-11"><a href="#至2021-08-11" class="headerlink" title="至2021-08-11"></a>至2021-08-11</h2><ol>
<li>object是引用数据类型，且只存储于堆(heap)中        ( <strong>X</strong> )</li>
</ol>
<p>​    解析：基本类型都存储在栈中，引用数据类型的引用存储在栈中，引用对象的内容存储在堆中</p>
<ol start="2">
<li>函数式声明有提升现象，函数表达式不会提升</li>
</ol>
<p>​    解析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1，实际执行顺序：先声明函数，再调用</span></span><br><span class="line">check(<span class="string">&#x27;first&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">ars</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ars);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 代码片段2，实际执行顺序：先声明变量，再调用函数（返回Uncaught ReferenceError），最后赋值</span></span><br><span class="line">check(<span class="string">&#x27;second&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> check= <span class="function"><span class="keyword">function</span>(<span class="params">ars</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="3">
<li>delete运算符只能删除自由属性，不能删除继承属性。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Book = &#123;</span><br><span class="line">  price: <span class="number">32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> book = <span class="built_in">Object</span>.create(Book);</span><br><span class="line">book.type = <span class="string">&#x27;Math&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> book.price; <span class="comment">//删除失败</span></span><br><span class="line"><span class="keyword">delete</span> book.type; <span class="comment">//删除成功</span></span><br><span class="line"><span class="built_in">console</span>.log(book.price); <span class="comment">//32</span></span><br><span class="line"><span class="built_in">console</span>.log(book.type); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>堆分为大顶堆和小顶堆，</p>
<p>满足a[i]&gt;=a[2i+1]&amp;&amp;a[i]&gt;=a[2i+2]称为<strong>大顶堆</strong>，</p>
<p>满足 a[i]&lt;=a[2i+1]&amp;&amp;a[i]&lt;=a[2i+2]称为<strong>小顶堆</strong></p>
</li>
<li><img src="/2021/08/11/notes/2.jpg" class="" title="This is an example image"></li>
<li><p>客户端渲染：浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。</p>
<p>服务器端渲染： 将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<p>服务器端渲染优点：</p>
<p>1.更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。<br>2.更快的内容到达时间，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。<br>缺点：<br>1.开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数中使用；一些外部扩展库可能需要特殊处理，才能在服务器渲染应用程序中运行。<br>2.涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。<br>3.更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
<li><p>有效防止XSS的手段有：</p>
<p>过滤用户请求中的非法字符</p>
<p>对请求中的特殊字符进行转译</p>
<p>配置CSP(Content Security Policy)</p>
</li>
<li><img src="/2021/08/11/notes/1.jpg" class="" title="This is an example image"></li>
<li><p>下面关于transform说法正确的是</p>
<p>只对受控于盒模型的元素生效</p>
<p>变形的原点默认是元素中心</p>
<p>可以通过matrix函数整合多种变形效果</p>
</li>
<li><p>CSS 中的以下几个属性能触发硬件加速：</p>
<ol>
<li>transform</li>
<li>opacity</li>
<li>filter</li>
<li>will-change</li>
</ol>
</li>
<li><img src="/2021/08/11/notes/3.jpg" class="" title="This is an example image"></li>
<li><p>XSS(Cross Site Scripting跨站脚本)。XSS定义的主语是“脚本”，是一种跨站执行的脚本，也就是javascript脚本，指的是在网站上注入我们的javascript脚本，执行非法操作。 </p>
<p>CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF定义的主语是”请求“，是一种跨站的伪造的请求，指的是跨站伪造用户的请求，模拟用户的操作.</p>
</li>
<li><p><code>Object.assign()</code>是浅拷贝</p>
</li>
<li><p>XSS(Cross Site Scripting跨站脚本)。XSS定义的主语是“脚本”，是一种跨站执行的脚本，也就是javascript脚本，指的是在网站上注入我们的javascript脚本，执行非法操作。 </p>
<p>CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF定义的主语是”请求“，是一种跨站的伪造的请求，指的是跨站伪造用户的请求，模拟用户的操作.</p>
<p>XSS攻击发生的条件是可以执行javascript脚本，一般在站点中总会有发表文章、留言等信息的表单，这种表单一般是写入到数据库中，然后在某个页面进行展示。我们可以在这些表单中直接编写javascript代码（<code>&lt;script&gt;alert(&quot;哈哈哈哈，你被攻击了!&quot;);&lt;/script&gt;</code>）进行测试，看是否可以执行。如果在信息展示页面js代码可以执行，XSS攻击就成功了。</p>
<p>CSRF攻击能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对</p>
</li>
<li><p>after伪元素清除浮动，设置在父容器中；隔墙法设置在子元素</p>
</li>
<li><p><code>typeof</code> 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。</p>
<p><strong>它返回值是一个字符串，该字符串说明运算数的类型。</strong></p>
<p>​    运算数为数字 typeof(x) = “number” </p>
<p>​    字符串 typeof(x) = “string” </p>
<p>​    布尔值 typeof(x) = “boolean” </p>
<p>​    对象,数组和null typeof(x) = “object” </p>
<p>​    函数 typeof(x) = “function” </p>
<p><strong><code>instanceof</code> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</strong></p>
<p><code>instanceof</code> 可以在继承关系中用来判断一个实例是否属于它的父类型。</p>
</li>
<li><p><strong>基本数据类型</strong>：<strong>Number、String、Boolean、Null、 Undefined、Symbol（ES6），</strong>这些类型可以直接操作保存在变量中的实际值。</p>
<p><strong>引用数据类型</strong>：<strong>Object（在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象）</strong></p>
</li>
<li><p><code>const</code>定义的对象\数组中的属性值可以修改,基础数据类型不可以</p>
</li>
</ol>
<h2 id="至2021-08-17"><a href="#至2021-08-17" class="headerlink" title="至2021-08-17"></a>至2021-08-17</h2><ol>
<li><p><strong>闭包</strong></p>
<p>闭包简单来说就是能够读取其他函数内部变量的函数，由于在<code>Javascript</code>语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被<strong>垃圾回收机制</strong>（garbage collection）回收。</p>
<p>这会使得函数中的变量都被保存在内存中，导致内存消耗变大，同时由于父函数内部的变量会被闭包获取到，可能会导致父函数内部的值被修改，产生一些意料之外问题</p>
<p>–&gt;<strong>垃圾回收机制</strong></p>
<p><code>JS</code>的垃圾回收机制是为了以防内存泄漏。变量生命周期结束后会被释放内存，<strong>全局变量</strong>的生命周期持续到浏览器关闭页面，<strong>局部变量</strong>的生命周期在函数执行后就结束了。</p>
<p><code>js</code>垃圾回收有两种方式：<strong>标记清除</strong>、<strong>引用计数</strong></p>
<p><strong>标记清除</strong>：</p>
<p>标记阶段：垃圾回收器从根对象开始遍历，每一个可以从根对象访问到的对象都会被添加一个可到达对象的标识。<br>清除阶段：垃圾回收器会对堆内存从头到尾进行线性遍历，如果有对象没有被标识为可到达对象，那么就将对应的内存回收，并清除可到达对象的标识，以便下次垃圾回收。</p>
<p><strong>引用计数：</strong></p>
<p>低版本的IE使用这种方式，但常常会引起内存泄露。原理是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时引用次数就是1，同一个值又被赋给另一个变量，引用次数+1，包含这个值当引用的变量取得新值，则引用次数-1，当垃圾回收器下次运行时，就会释放那些引用次数0的值占用的内存。</p>
</li>
<li><p><strong>深浅拷贝</strong></p>
<p>深浅拷贝针对的是引用数据类型，浅拷贝指的是只复制指向某个对象的指针，多个指针指向同一块内存，真正的内容只有一份，深拷贝指的是复制一份一模一样的对象，两个对象相互独立；</p>
<p>-&gt;<strong>基本数据类型</strong>：<strong>Number、String、Boolean、Null、 Undefined、Symbol（ES6），</strong>这些类型可以直接操作保存在变量中的实际值。</p>
<p>-&gt;<strong>引用数据类型</strong>：<strong>Object（在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象）</strong></p>
<p>我在实习的时候，用<code>Vue</code>把我之前的那个简单的项目改写了一下，其中有一个网页要实现一个简单的排序功能，数据都在一个数组中，我的做法是将原始数据保持不变，声明一个新的变量存放排序后的数组，然后页面上渲染排序后的数据。这个过程中就遇到了深浅拷贝的问题，一开始我直接用等号赋值，实际上是浅拷贝，导致直接对原始数据进行了操作，最终无法实现重置的功能。后来改成了用展开操作符赋值，解决了问题</p>
<p>-&gt;<strong>各种排序</strong></p>
<p>​    <strong>冒泡排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                temp = arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    时间复杂度O(n^2)，空间复杂度O(1)，稳定性：稳定</p>
<p>​    <strong>快速排序</strong></p>
<p>​    分治思想，思路：</p>
<p>​    1、选择数组中间数作为基数，并从数组中取出此基数；</p>
<p>​    2、准备两个数组容器，遍历数组，逐个与基数比对，较小的放左边容器，较大的放右边容器；</p>
<p>​    3、递归处理两个容器的元素，并将处理后的数据与基数按大小合并成一个数组，返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr &#125;</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) <span class="comment">//基准的序号，向下取整</span></span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>] <span class="comment">//基准的值</span></span><br><span class="line">    <span class="keyword">let</span> left = []</span><br><span class="line">    <span class="keyword">let</span> right = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">            left.push(arr[i])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right)) <span class="comment">//递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    时间复杂度O(nlogn)，空间复杂度O(logn)，稳定性：不稳定</p>
<p>​    <strong>插入排序</strong></p>
<p>​    类似于整理扑克牌，把每一张都插入到当前的最佳位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> preIndex = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="literal">null</span> <span class="comment">//本次循环中源位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span></span><br><span class="line">        current = arr[i]</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current)&#123;</span><br><span class="line">            <span class="comment">//往后挪</span></span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex]</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入数值</span></span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    时间复杂度O(n^2)，空间复杂度O(1)，稳定性：稳定</p>
<p>​    <strong>选择排序</strong></p>
<p>​    选择一个数作为基准，对比其后面的数，遍历寻找其中最小的数，结束后将最小的数和基准进行交换，不断重复</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> tempNum = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        minIndex = i <span class="comment">//基准为i</span></span><br><span class="line">        <span class="comment">//从基准后一位开始找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到一个最小值的索引</span></span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        tempNum = arr[minIndex]</span><br><span class="line">        arr[minIndex] = arr[i]</span><br><span class="line">        arr[i] = tempNum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    时间复杂度O(n^2)，空间复杂度O(1)，稳定性：不稳定</p>
<p>-&gt;<strong>深拷贝方法</strong></p>
<p>​    1.<code>Object.assign()</code>是深拷贝还是浅拷贝<br>​    当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</p>
<p>​    2. <code>obj2 = JSON.parse( JSON.stringify(obj1) )</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">            name: <span class="string">&#x27;JJ&#x27;</span>,</span><br><span class="line">            age: <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">        b.age = <span class="number">25</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure>

<p>​    3. 对于数组：<code>newArr = arr.map( item =&gt; item)</code></p>
<p>-&gt;展开操作符</p>
<p>用…扩展一个数组对象和字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...<span class="string">&#x27;hey&#x27;</span>]) <span class="comment">//  [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;y&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>如果是对象，对象内部的引用数据类型不会深拷贝，而是浅拷贝</p>
</li>
<li><p>常见<code>ES6</code>标准</p>
<ul>
<li><p><code>let</code>, <code>const</code></p>
<p>​    -&gt; <code>let</code>,<code>const</code>, <code>var</code>区别：</p>
<p>​        <code>var</code>变量提升，没有块级作用域 ，重复声明会覆盖； 任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>
<p>​        <code>let</code>有块级作用域，不会变量提升，不能重复声明，暂时性死区：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>​        <code>const</code>必须有初始值，不会变量提升，不能重复声明，暂时性死区，值无法改变，对象除外，因为本质是引用，修改的是内存中的内容，而不是指针</p>
</li>
<li><p>解构赋值</p>
</li>
<li><p>模板字符串（``反引号），个人的理解是可以实现动态字符串，用${}来包裹变量</p>
</li>
<li><p><code>map()</code> <code>foreach()</code> 可能会问到二者的区别：<code>map()</code>会返回一个新的数组，而<code>foreach()</code>不会</p>
</li>
<li><p>Promise promise是为了解决有些时候回调函数过多的问题，也就是所谓回调地狱，他是一个对象，总共有三种状态，分别是pending，resolved和rejected，它的构造函数接受一个函数作为参数，该函数有两个参数，分别是resolve和reject，resolve的作用就是将该promise的状态变成resolved，并且可以将参数传递出去，reject的作用是将状态变成rejected，也可以将错误信息传递出去；promise还有一个叫then()的方法，它接受两个参数，第一个是promise resolved时的回调函数，第二个是rejected时的回调函数，第二个参数不是必须的，同时then()里也可以返回promise，因为在then中使用了return，那么return的值会被<code>Promise.resolve()</code> 包装，这样就可以链式调用，提高代码的可读性</p>
</li>
</ul>
</li>
<li><p><code>Vue</code></p>
<ul>
<li><p>双向绑定原理</p>
<p>利用数据劫持结合发布者-订阅者模式实现，需要一个监听器Observer，订阅者Watcher和解析器Compiler，监听器通过<code>Object.defineProperty()</code>递归地为每一个属性添加getter和setter，特别是setter，这样可以在属性的值发生变化时被Observer监听到，然后通知订阅者，订阅者收到通知后执行相关的函数，更新视图；编译器Complier来解析编译模板指令，就是去遍历寻找有指令的节点，然后初始化节点，为它绑定更新函数，初始化订阅器，这样就实现了数据的双向绑定。总体来说就是编译器寻找带有指令的节点，绑定订阅器，监听武器监听到属性变化时，会通知订阅器，从而更新视图，订阅器是二者之间的桥梁</p>
</li>
<li><p>组件通讯方式</p>
<p>首先是最基础的<code>props</code>，可以从父组件向子组件传递数据，<code>$emit</code>从子组件触发父组件的事件，将子组件的数据通过传参的方式传给父组件</p>
<p><code>$parent</code>和<code>$children</code>直接操作父子组件实例，不过<code>$children</code>是数组类型，不保证顺序也不是响应式的</p>
<p><code>EventBus</code>提供一根事件总线，可以在任何组件之间通讯，通过<code>bus.$emit()</code>触发事件，<code>bus.$on()</code>监听事件</p>
<p><code>Vuex</code>：了解过，个人的理解是和<code>EventBus</code>有一个共同的思想，就是用一个总的容器来控制全局，不过是用来进行组件状态管理的，比<code>EventBus</code>的适用范围要广。工作流程大概是在Vue根组件上挂载一个Store实例，这个实例中有一个State属性，可以存放各种组件的状态，有一个Getter相当于一个计算属性，对State进行操作，一个Mutation，里面定义了一些可以修改State中的值的方法，组件可以通过commit提交这些方法，来修改State中的值，但是这些方法必须是同步的，因为<code>devtools</code>需要打印出mutation执行前后的状态快照，如果是异步操作，会导致状态无法追踪，如果需要异步，要用到action，action通过<code>Store.dispatch()</code>触发，action内部可以执行异步操作，通过commit提交mutation来修改state中的值。最后，为了防止单一的store过于庞大，可以用将其分割成多个modules</p>
</li>
<li><p>生命周期</p>
<p><code>beforeCreate</code>: 只有一些初始事件，没有data，methods等</p>
<p><code>created</code>：有data，methods等，可以进行初始数据的请求，处理之类的操作，但不能进行DOM操作</p>
<p><code>beforeMount</code>：判断el的挂载方式，如果没有el，会等待调用<code>$mount(el)</code> 判断是否有template设置 将template进行渲染保存到内存当中，还未挂载在页面上</p>
<p><code>mounted</code>：此时可以进行DOM操作</p>
<p><code>beforeUpdate</code>：数据更新，但DOM还没更新</p>
<p><code>updated</code>：根据data里的最新数据渲染出最新的DOM树，然后将最新的DOM挂载到页面 此时data和页面数据一致，都是最新的</p>
<p><code>beforeDestroy</code>：此时组件从运行阶段进入到销毁阶段 组件上的data和methods以及过滤器等都出于可用状态，销毁还未执行，一般用来解绑事件之类</p>
<p><code>destroyed</code>：组件销毁，子组件，事件监听器之类都会被销毁</p>
<p>组件生命周期调用顺序：</p>
<p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p>
<p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p>
<p>加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</p>
<p>子组件更新过程 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>
<p>父组件更新过程 父 beforeUpdate -&gt; 父 updated</p>
<p>销毁过程 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>
</li>
<li><p><code>MVVM</code>：Modle View View-Model，Model控制数据，View控制视图，View-Model是二者之间的桥梁，数据更新时，Model通知View-Model，View-Model会自动的更新视图；同样的，当视图更新时，View-Model会更新数据，这可以将视图和业务逻辑分隔开，降低耦合度</p>
</li>
</ul>
</li>
<li><p><code>Vue-router</code></p>
<p><code>hash路由</code>和<code>history路由</code>：</p>
<p>​    hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被    包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</p>
<p>​    history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</p>
<p>​    项目中用的是默认的hash模式，</p>
<p>相应路由参数变化：</p>
<p>​    watch<code>$router</code>对象</p>
<p>路由守卫：</p>
<p>​    <code>router.beforeEach(to, from, next)</code>：全局前置守卫，to表示要哪，from表示从哪来，next是一个函数，相当于promise中的resolve，如果不调用next，这个守卫会一直处于一个等待中的状态，我个人目前用它来处理一些跳转逻辑，比如验证登录状态，如果登录了，就调用next放行到主页，如果未登录，就强制跳转到登陆页面</p>
<p>​    还有一些组件内的守卫，<code>beforeRouteEnter(to, from, next)``beforeRouteLeave(to, from, next)</code>用来根据业务需要，在组件内部处理跳转的逻辑，比如说<code>beforeRouteLeave()</code>可以在用户离开页面之前来向用户确认是否要保存未修改的内容之类。</p>
<p>跳转方式：</p>
<p>​    声明式：<code>&lt;router-link :to=&quot;&#123;路径，参数&#125;&quot;&gt;&lt;/router-link&gt;</code> </p>
<p>​    编程式：<code>this.$router.push(&#123;path: &#39;&#39;, query or param: &#39;&#39;&#125;)</code></p>
<p>​        <code>param</code>：显示在url上，刷新时会失去里面的内容</p>
<p>​        <code>query</code>：不显示在url上，刷新时内容不会失去</p>
<p>​    声明式的本质是调用<code>router.push()</code></p>
</li>
<li><p><code>axios</code></p>
<p><code>axios</code>基于Promise，本质上也是对原生XHR的封装，但是是Promise的实现版本，所以使用起来非常方便直观，小型项目的话可以直接使用<code>axios(config)</code>来发起请求，<code>config</code>中可以配置请求的参数，比如<code>method``url``data</code>之类，<code>method</code>有<code>get``post``delete``put``options</code>，我比较熟悉的是<code>get</code>, <code>post</code>, <code>get</code>是用来向服务端请求数据的，如果携带参数的话，参数会在url中显示，因此会受到浏览器url的长度限制，导致参数的传递存在上限，同时传递参数会被直接看到，不应该用来传递敏感数据，同时<code>get</code>的数据只允许ASCII字符<code>post</code>是用来向服务器提交数据的，并且提交的数据不会在url中显示，也没有大小的限制，更加安全，数据格式也没有限制；此外<code>delete</code>是用来让服务器删除指定数据的，<code>options</code>一般会在两种情况下出现，一种是向服务器获取支持的http通信方法，还有一种就是在跨域的时候进行预检请求，通过先发送一个<code>options</code>方法，来检查请求是否安全，如果安全才会进行接下来的请求，但是只有复杂请求会有<code>options</code>，复杂请求要满足一下任意一种情况：如果方法是<code>put, delete, patch, post</code>中的一种，或者数据是<code>json</code>格式，换言之不是<code>text/plain, urlencoded, formdata </code>这三种格式之一，或者请求中有自定义的头部，只要满足这其中的一种，就算是复杂请求，复杂请求在跨域时会发出预检请求。</p>
<p><code>fetch</code>和<code>axios</code>的区别</p>
<p><code>fetch</code>是原生js，而不是封装XHR，</p>
<p><code>fetch</code>只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，<code>fetch</code> 才会被<code>reject</code>。</p>
<p><code>fetch</code>没有办法原生监测请求的进度，而XHR可以</p>
<p>相同点：<code>fetch</code>和<code>axios</code>都是基于promise，默认都不携带cookie</p>
<p>-&gt;<strong>跨域</strong></p>
<p>跨域是由于浏览器的同源政策，它限制了页面之间的通信条件，两个页面如果不是同源的，就无法通信，无法读取<code>cookie</code>，<code>localStorage</code>，无法发送请求等，而这个同源，指的是协议+域名+端口号三者完全相同，有任何一个不同的都算做跨域，就会受到限制，同源政策的目的是防止XSS，XSRF等，从而保护用户的安全。不过这样也会导致正常的通信受到限制，如果不跨域的话，在向服务器请求数据的时候就会变得非常困难，所以需要解决跨域问题。解决方案有以下几种，首先是<code>jsonp</code>，它可以解决服务器和客户端之间的跨域问题，利用了<code>&lt;script&gt;</code>标签不受同源政策限制的特点，通过将其src属性值设置为要请求的服务器地址，并在url中添加携带的参数(如果有需要的话)，和get方法非常像，并且还有一个<code>callback</code>参数，用来指定请求返回后的回调函数，服务器收到请求后会把数据放在回调函数的参数中返回，返回后这个函数会立即执行，从而实现跨域请求的效果，但是只支持get请求。第二种是CORS跨域资源共享，是目前主流的解决办法，方法是服务器设置相应头中的<code>Access-Control-Allow-Origin</code>为对应的域名即可，如果开启cookie的话，前后端都要设置<code>Access-Control-Allow-Credentials: true</code>。此外还有<code>websocket</code>协议，实现浏览器和服务器全双工通信，这个协议不实行同源政策，因此可以跨域；开发过程中，前端可以设置开启代理服务器，将请求发送给代理服务器，然后代理服务器转发请求至真正的服务器，由于是服务器之间的请求，不会受到同源政策限制，收到响应后再由代理服务器转发给前端，从而实现跨域；以上是前后端通信的跨域，还有一些页面之间的跨域，比如通过自带的<code>window.postMessage()</code>方法，还有比如说当两个页面的二级域名相同时，可以设置这两个页面的<code>document.domain = &#39;同一个域名&#39;</code>来实现页面之间的通信。</p>
<p>-&gt;<code>cookie</code>, <code>localStorage</code>, <code>sessionStorage</code></p>
<p>​    相同点：都保存在浏览器端，且同源</p>
<p>​    不同点：<code>cookie</code>会一直在服务器和浏览器之间传递，<code>localStorage</code>, <code>sessionStorage</code>只是保存在本地；<code>cookie</code>的大小一般不    能超过4K，而<code>localStorage</code>, <code>sessionStorage</code>可以达到5M以上；除此之外，<code>cookie</code>在设置的过期时间之前一直有效，在同源    窗口中共享，<code>sessionStorage</code>只在窗口关闭之前有效，并且即使是同一个页面也不会共享，<code>localStorage</code>只要不被清除，就一    直有效，在同源窗口中共享。</p>
<p>-&gt;<strong>XSS, XSRF</strong></p>
<p>​    XSS(Cross Site Scripting跨站脚本)。一般来说是在提交的内容中注入一些JavaScript代码来进行攻击 ，可以通过过滤掉或者替换掉    关键字，比如html标签，js事件等，或者是将内容重新编码，使得内容仅仅被显示而不会被执行</p>
<p>​    XSRF（Cross-site request forgery）跨站请求伪造，指的是跨站伪造用户的请求，模拟用户的操作，比如用户同时打开了一个普通    网站和一个恶意网站，这个恶意网站通过获取用户在普通网站的<code>cookie</code>，来模拟用户操作，向服务器发送恶意请求。可以通过验    证HTTP请求中的Referer字段来防御，或者是服务器生成token并返回给客户端，之后客户端的请求需要携带token</p>
</li>
<li><p><strong>http状态码</strong></p>
<p>200 成功处理请求</p>
<p>404 找不到页面；具体情况：后端ip地址变了</p>
<p>401 用户没有权限</p>
<p>403 用户有授权但访问被禁止</p>
<p>302 临时重定向；具体情况：后端同事为了调试，把接口临时移到了别的地方</p>
<p>304 内容没有改变，可以引出协商缓存机制</p>
<p>500 服务器遇到未曾预料的错误，无法处理请求；具体情况：识别引擎崩了，后端接口还开着，但是处理不了前端发过来的数据，导致返回500</p>
<p>-&gt;<strong>协商缓存</strong>，<strong>强缓存</strong></p>
<p>​    强缓存：直接读取本地缓存，返回200，分为两种<code>expires</code>和<code>cache-control</code>，<code>expires</code>表示过期时间，是一个固定的时间戳，存在问题：与客户端时间对比，客户端时间可以修改，且服务器和客户端时间可能不一致；<code>cache-control</code>表示资源多长时间后国企，是一个时间长度，比<code>expires</code>更好</p>
<p>​    协商缓存：与服务器对比，若没有改变，则读取本地缓存，返回304，分为两种<code>last-modified</code>和<code>etag</code>，<code>last-modified</code>表示该资源最后修改的时间，与请求中的<code>if-modified-since</code>字段对比，如果相同则返回304，不同则返回新的资源，并修改<code>last-modified</code>，存在的问题：只要编辑了，不管内容是否真的修改，都会被判断为已修改，导致不必要的传输；时间精确到秒，如果是一秒内的修改则不会被检测到。<code>etag</code>是基于内容编码生成的字符串，代表了内容的唯一性，当<code>etag</code>和<code>if-none-match</code>相同时，返回304，否则返回新的资源，并更新<code>etag</code>，因此<code>etag</code>要优于<code>last-modified</code>，但是生成编码会提高服务器开销。</p>
<p>​    所有字段都是在服务器的响应头中添加。</p>
</li>
<li><p><strong>输入url后发生了什么</strong></p>
<p>首先构建请求</p>
<p>如果有强缓存，并且没有过期，直接使用</p>
<p>否则要去找到对应的ip地址以建立连接，找ip地址的时候，首先去查找本地是否有缓存，依次从浏览器缓存，系统缓存，路由器缓存，系统hosts文件中查找，如果都没有，则向DNS服务器请求，得到服务器的ip地址，</p>
<p>然后向服务器发起TCP连接，并把http请求发送给服务器，服务器处理请求，并返回相应结果，这里只考虑结果是一个html文件的情况，浏览器在收到该文件后，开始构建页面</p>
<p>首先根据html构建DOM树，其间如果遇到js脚本和外部js连接，会停止构建DOM树，转而先执行和下载响应代码，因此js代码最好放在html代码后面，防止页面加载卡顿，影响用户体验；同时遇到一些静态资源比如图片，音频等，会先判断是否有缓存，如果有则直接使用，否则进行并行下载</p>
<p>然后根据外联样式，内部样式，内联样式，来构建CSSOM树</p>
<p>构建完毕后将CSSOM树和DOM树合并成为渲染树</p>
<p>然后进行布局，确定各个元素的位置和尺寸</p>
<p>最后就是渲染页面，呈现给用户</p>
</li>
<li><p><strong>普通函数和箭头函数的区别</strong></p>
<ol>
<li>this方面：</li>
</ol>
<p>普通函数内部的this，默认指向window，严格模式下指向undefined；</p>
<p>箭头函数内部的this，与上一级作用域中的this指向同一个地方。</p>
<ol start="2">
<li>arguments方面：</li>
</ol>
<p>普通函数，可以通过arguments来实现重载；</p>
<p>箭头函数中，没有arguments，代替它功能是剩余参数rest（…）。</p>
<ol start="3">
<li>原型对象方面：</li>
</ol>
<p>普通函数，是有自己的原型对象的；</p>
<p>箭头函数，没有原型对象。</p>
<ol start="4">
<li>new方面：</li>
</ol>
<p>普通函数，可以作为构造函数，通过new实例化出子函数；</p>
<p>箭头函数，不能作为构造函数，使用new会报错。</p>
<ol start="5">
<li>简易程度：</li>
</ol>
<p>箭头函数比普通函数的使用简短更多；同时箭头函数通常是匿名函数。</p>
</li>
<li><p>事件循环</p>
<p>先执行所有宏任务，完毕后执行微任务，更新render，重复</p>
<p>宏任务：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</p>
<p>微任务：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>
</li>
</ol>
<h2 id="至2021-08-18"><a href="#至2021-08-18" class="headerlink" title="至2021-08-18"></a>至2021-08-18</h2><ol>
<li><p>防抖函数及优化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay, immediate, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="comment">//如果有计时器，清空计时器</span></span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//立即执行的情况</span></span><br><span class="line">        <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">            <span class="keyword">let</span> canRun = !timer</span><br><span class="line">            <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">                func.apply(_this, args) <span class="comment">//this也行, 因为args是一个数组，所以用apply()</span></span><br><span class="line">            &#125;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span> <span class="comment">//清空timer，这样下一次进来就会立刻执行</span></span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不用立即执行的情况</span></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">realFun</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myButton&#x27;</span>).onclick = debounce(realFun, <span class="number">1000</span>, <span class="literal">false</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>节流函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay, immediate, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> curTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">            <span class="comment">//用状态变量的版本</span></span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">                valid = <span class="literal">false</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    valid = <span class="literal">true</span></span><br><span class="line">                &#125;, delay);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用计时器的版本</span></span><br><span class="line">            <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">                func.apply(_this, args) </span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    timer = <span class="literal">null</span></span><br><span class="line">                &#125;, delay);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用时间戳的版本</span></span><br><span class="line">            <span class="keyword">if</span>(curTime - startTime &gt; <span class="number">500</span>)&#123; <span class="comment">//500可以改成一个参数传入，为每多少秒必须触发一次</span></span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">                startTime = curTime</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//用状态变量的版本</span></span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                valid = <span class="literal">false</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    func.apply(_this, args)</span><br><span class="line">                    valid = <span class="literal">true</span></span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用计时器的版本</span></span><br><span class="line">            <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    func.apply(_this, args)</span><br><span class="line">                    timer = <span class="literal">null</span></span><br><span class="line">                &#125;, delay);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//用时间戳的版本</span></span><br><span class="line">            <span class="comment">//第一次触发，最后再触发一次，好像用时间戳做不到第一次不触发</span></span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">            <span class="keyword">if</span>(curTime - startTime &gt; <span class="number">500</span>)&#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">                startTime = curTime</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    func.apply(_this, args)</span><br><span class="line">                &#125;, delay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>瓶盖递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bottle = <span class="number">0</span>; <span class="comment">//瓶盖数</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>; <span class="comment">//瓶子数</span></span><br><span class="line"><span class="keyword">let</span> money = <span class="number">20</span>; <span class="comment">//钱的数量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buyWater</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(money &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        money--</span><br><span class="line">        num++</span><br><span class="line">        bottle++</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(bottle === <span class="number">3</span>)&#123;</span><br><span class="line">            money++</span><br><span class="line">            bottle = <span class="number">0</span></span><br><span class="line">            buyWater()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">buyWater()</span><br><span class="line"><span class="built_in">console</span>.log(num, bottle)</span><br></pre></td></tr></table></figure></li>
<li><p>this绑定的四种方法</p>
<ol>
<li><p>默认绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar=<span class="number">2021</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bar=<span class="number">1998</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);</span><br><span class="line">    &#125;</span><br><span class="line">foo();<span class="comment">//2021，没有调用对象，this默认指向了window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> bar=<span class="number">2021</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar=<span class="number">1998</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//Uncaught TypeError: Cannot read property &#x27;bar&#x27; of undefined</span></span><br><span class="line">	  <span class="comment">//严格模式下，不允许this指向window，因此是undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p>隐式绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="number">1998</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    foo:<span class="number">2021</span>,</span><br><span class="line">    bar:bar,</span><br><span class="line">    obj2:&#123;</span><br><span class="line">        foo: <span class="number">2022</span>,</span><br><span class="line">        bar: bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.bar();<span class="comment">//2021 函数被调用时，将this隐式绑定到了上下文对象，并且指向离函数最近的对象</span></span><br><span class="line">obj.obj2.bar();<span class="comment">//2022</span></span><br></pre></td></tr></table></figure>

<p>隐式丢失</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="number">1998</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    foo:<span class="number">2021</span>,</span><br><span class="line">    bar:bar       </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz=obj.bar;</span><br><span class="line">baz();<span class="comment">//1998 相当于 baz = bar，this直接指向了window</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> foo=<span class="number">1998</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    foo:<span class="number">2021</span>,</span><br><span class="line">    bar:bar       </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.bar,<span class="number">0</span>)<span class="comment">//1998 匿名函数的this指向window</span></span><br></pre></td></tr></table></figure></li>
<li><p>硬绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;我是全局 foo&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">    foo:<span class="string">&quot;我是obj1 foo&quot;</span>,</span><br><span class="line">    bar:bar       </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">    foo:<span class="string">&quot;我是obj2 foo&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3=&#123;</span><br><span class="line">    foo:<span class="string">&quot;我是obj3 foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">obj1.bar.apply(obj2)<span class="comment">//我是obj2 foo</span></span><br><span class="line">obj1.bar.call(obj3)<span class="comment">//我是obj3 foo</span></span><br><span class="line">obj2.bar.bind(obj3)()<span class="comment">//我是obj3 foo</span></span><br></pre></td></tr></table></figure></li>
<li><p>new绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;我是全局 foo&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.foo=foo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz=<span class="keyword">new</span> bar(<span class="string">&quot;新传的bar&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz.foo);<span class="comment">//新传的bar</span></span><br></pre></td></tr></table></figure>

<p>在定义好函数后，都会new一下，生成一个新的对象，new的过程中会执行下面的操作：</p>
<p>1、创建一个全新的对象</p>
<p>2、给这个对象挂载prototype属性</p>
<p>3、新对象会绑定到函数调用的this（调用这个对象下的函数方法时，this会指向该对象）</p>
<p>4、如果函数没有返回其他对象，那new表达式中的函数调用会返回这个新对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj) <span class="comment">//箭头函数创建时的this根据上下文来，即foo()的this，它被绑定到了obj，因此箭头函数的this指向obj</span></span><br><span class="line">bar.call(obj1) <span class="comment">//7 箭头函数的this无法修改</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>eccent
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://eccent.icu/2021/08/11/notes/" title="随手一记">http://eccent.icu/2021/08/11/notes/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"># 学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/20/vue-import/" rel="prev" title="Vue导入外部js库的两种方法">
      <i class="fa fa-chevron-left"></i> Vue导入外部js库的两种方法
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

 
   <div>
     <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
   </div>
 



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MzE0NS8yOTYyMQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%B32021-08-11"><span class="nav-number">1.</span> <span class="nav-text">至2021-08-11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%B32021-08-17"><span class="nav-number">2.</span> <span class="nav-text">至2021-08-17</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%B32021-08-18"><span class="nav-number">3.</span> <span class="nav-text">至2021-08-18</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="eccent"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">eccent</p>
  <div class="site-description" itemprop="description">Stay Alive</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/eccente" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eccente" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-04 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eccent</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共14.9k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
